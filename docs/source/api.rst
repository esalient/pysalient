API Reference
=============

This section provides detailed API references for the pysSALIENT framework modules.

IO Module
---------

.. automodule:: pysalient.io
   :members:

Functions for exporting results:

.. autofunction:: pysalient.io.export_evaluation_results

.. autofunction:: pysalient.io.export_formatted_results

Evaluation Module
-----------------

.. automodule:: pysalient.evaluation
   :members:

Time-to-Event Metrics
^^^^^^^^^^^^^^^^^^^^^

The evaluation module now supports calculating time-to-event metrics for clinical events. 
These metrics calculate the time from model alerts to clinical events for true positives only, 
aggregated at the encounter level.

Key parameters for time-to-event functionality:

- ``time_to_event_cols``: Dictionary mapping metric names to clinical event column names
- ``aggregation_func``: Aggregation function for encounter-level aggregation (default: "median")

For detailed parameter documentation and examples, see the :func:`pysalient.evaluation.evaluation` function docstring.


Visualisation and Display Helpers
---------------------------------

This module provides helper functions for visualizing and displaying results generated by other pysalient modules, particularly the evaluation results table.

.. automodule:: pysalient.visualisation
   :members:
   :undoc-members:
   :show-inheritance:

Usage Example
^^^^^^^^^^^^^

The primary function currently is `format_evaluation_table`, which helps display the float values in the evaluation results table with consistent formatting in environments like Jupyter notebooks.

.. code-block:: python

   import pysalient.evaluation as eval
   import pysalient.visualisation as vis
   import pysalient.io as io # Assuming io is used to load data

   # --- Load your data ---
   # Example using sample data and assigned names
   sample_data_path = 'data/anonymised_sample.parquet' # Adjust path as needed
   col_map = {
       'y_proba': 'prediction_probability',
       'y_label': 'true_label',
       'agg': 'encounter_id',
       'time': 'event_timestamp',
   }
   assigned_table = io.load_evaluation_data(
       source=sample_data_path,
       y_proba_col=col_map['y_proba'],
       y_label_col=col_map['y_label'],
       aggregation_cols=col_map['agg'],
       timeseries_col=col_map['time'],
       assign_task_name="AKI",
       assign_model_name="LogRegress",
       perform_aggregation=True,  # Enable aggregation by encounter
       label_agg_func="max"  # Use max aggregation for labels (any positive makes group positive)
   )

   # --- Run evaluation ---
   # Note: 'assigned_table' was loaded with 'timeseries_col' set to 'event_timestamp'.
   # The 'evaluation' function will use this along with the new time-to-event parameters.
   results_table = eval.evaluation(
       data=assigned_table,
       modelid="BaselineLogisticRegression",
       filter_desc="placeholder_filter",
       thresholds=(0.1, 0.9, 0.1),
       timeseries_col=col_map['time'], # Alert timestamps for time-to-first-alert
       time_unit="hours", # Required when timeseries_col is numeric
       time_to_event_cols={
           'culture': 'blood_culture_timestamp',
           'antibiotics': 'antibiotic_timestamp'
       }, # Optional: clinical event columns for time-to-event metrics
       aggregation_func="median", # Aggregation function for time-to-event (default: median)
       decimal_places=3 # Evaluation rounding (optional)
   )

   # The 'results_table' will now contain dynamic columns for time-to-event metrics:
   # - 'median_hrs_from_first_alert_to_culture' (or other aggregation function)
   # - 'count_first_alerts_before_culture' 
   # - 'count_first_alerts_after_or_at_culture'
   # - Similar columns for 'antibiotics' 
   # - Standard 'time_to_first_alert_value' for when model first exceeds threshold

   # --- Format for display ---
   # Use the helper to format float columns (e.g., to 3 decimal places)
   styled_table = vis.format_evaluation_table(results_table, decimal_places=3)

   # Display in Jupyter/IPython
   # display(styled_table) # Uncomment in a notebook environment

   # If not in Jupyter, you might render to HTML
   # html_output = styled_table.render()
   # print(html_output)
